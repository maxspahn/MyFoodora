\section{Coding problems and their solutions}
\label{sec:coding_problems_and_their_solutions}

\subsection{Allocate a \textsc{Courier} to an order}
\label{sub:allocate_a_courier_to_an_order}

Beside the use of the Strategy-pattern to choose between the different delivery policy, there were
some other important choices for the implementation of this feature. The \textsc{allocate} method 
is written in the two different implementations of the Delivery interface. Since the system is 
just used locally by one user at a time, it was not possible to create a interaction of ordering
by a customer and the accepting of the delivery by a courier. In order to imitate some this 
behavior we worked with a accepting-probability for the courier, which can be set in the core of
the \textsc{MyFoodoar} system. 

The fact that a courier can reject the delivery of an order caused a problem when allocating the 
courier to the order. We solved this problem with a \textit{while-loop} that only ends when
a courier is found who is available and accept the order. In order to avoid that one courier who
has rejected an order does not get the same order once again, he is added to a temporary list of
couriers. We find this problem while testing the code with the \textit{JUnit-Tests}. The tests 
also revealed an error in the allocating algorithm. Before we did not check if the chosen 
courier was \textit{On-Duty}.

\lstinputlisting[firstline=20, lastline=35]{./../src/system/FairDelivery.java} 

\subsection{Exceptions}
\label{sub:exceptions}

In our first approach we tried to avoid any kind of \lstinline|Exception| because we were
not convinced of its utility. We handled the possibility that there might occur wrong inputs at
several places with simple \lstinline|System.out.println()|. At first this seemed to be a
sufficient solution. As we continued to implement further parts of the system we realized that it
was becoming more and more confusing where the \lstinline|System.out.println()| is actually 
invoked. The solution was obviously the implementation of \lstinline|Exception| and we sacrificed
some time in their creation. Later in the project-work we realized that this choice was the right
one since the implementation of the \textsc{Command-Line-User-Interface} and the \textsc{GUI} were
much easier this way.

\subsection{Serialization}
\label{sub:serialization}
After having finished most of our program, we were a bit frustrated because we felt like our code was not a "real software". Indeed, after the execution of the CLUI and the closure of our program, all the datas created by the user vanished, which means that at the restart of the CLUI, everything created before did not exist anymore. To avoid this problem and to make our software more realistic, we decided to serialize all the attributes of MyFoodora at the shut down of the program (done by the command \textit{"q"}) in a file \textit{MyFoodoraDatas.txt}.
Hence at the launch of the software, 2	cases are taken into account in the constructor of MyFoodora:
\begin{itemize}
	\item{} This is the first launch and therefore there is no file containing serialized datas, and the constructor initializes all the attributes of MyFoodora with default values.
	\item{} The file \textit{MyFoodoraDatas.txt} has already been created and the constructor initializes the attributes of MyFoodora by deserializing it. So all the attributes of MyFoodora are the same that there were before the last shut down. 	
\end{itemize}
\lstinputlisting[firstline=1,lastline=15]{./Code/src/Code/constructorMyFoodora.txt}
However, we had trouble to implement this serialization. At the beginning we thought that only the class \textit{MyFoodora} and those which are instantiated as attributes of it needed to implement the interface \textit{Serializable}. Nevertheless, it took time to understand that all the classes are "connected" with each other, and that all of them need to implement \textit{Serializable}.
